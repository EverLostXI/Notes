# ECE4010 机器学习与应用

* 成绩占比：

  作业（30%）共三次

  期中（40%）

  小组项目（30%）

  1. 所有成员的分数相同
  2. 70%教员评分，30%同学评分

  课堂参与分（额外10%）

## C1 搜索

1. 一些概念

   agent: 能够感知环境并作出反应的实体

   state: agent与环境的整体状态

   action: 给定状态下可以做出的选择

   * ACTIONS(s)返回在s状态下可以执行的所有action

   transition model: 描述action如何转换状态

   * RESULT(s, a)返回在状态s下执行动作a会导致的状态

   state space: 从初始状态开始，通过所有可能的动作所能达到的所有状态之集

   path cost: 执行某一路径的的消耗（所有动作的消耗相同）

   solution: 能够从初始状态去到终点状态的一系列动作

   optimal solution: 拥有最小路径耗损的解

   node: 一种数据结构，用于记录：

   * 当前状态
   * 父节点
   * 从父节点到这里的动作
   * 路径耗损（从初始状态到这里）

2. 搜索算法

   Frontier（前沿）：某种用于暂存node的容器

   1. 算法框架

      1. 通用搜索（没有已探索集）

         * 从包含初始节点的前沿开始
         * 重复：
           1. 若前沿中没有节点则无解
           2. 移除第一个节点
           3. 若包含最终节点则返回最终节点
           4. 将移除的节点的子节点加入前沿中

         问题：不包含已探索集，所以可能发生死循环

      2. 图搜索（有已探索集）

         * 从包含初始节点的前沿和空无一物的已探索集开始
         * 重复：
           1. 若前沿中没有节点则无解
           2. 移除第一个节点
           3. 若包含最终节点则返回最终节点
           4. 将移除的节点加已探索集
           5. 将移除的节点的子节点加入前沿中

   2. 无信息搜索（没有启发函数）

      1. 深度优先搜索

         用堆栈作为前沿的数据结构

      2. 广度优先搜索

         用队列作为前沿的数据结构

   3. 有信息搜索（有启发函数）

      启发函数其实就是让前沿变成了某种优先队列

      1. 贪婪最佳优先算法

         启发算法：只关心当前节点到目标节点的估算距离（曼哈顿距离），选择估算距离最小的节点

         曼哈顿距离：横向差值+纵向差值

      2. A*算法

         启发算法：选择路径损耗+估算距离最小的节点

   ## C2 对抗搜索

   1. 基础概念

      S~0~：初始状态
   
      PLAYER(s)：决定哪方走下一步
   
      ACTIONS(s)：当前状态所有可能走法
   
      RESULT(s, a)：执行某个动作之后的得到的新状态
   
      TERMINAL(s)：判断游戏是否结束
   
      UTILITY(s)：游戏结束时的分值
   
   2. MINIMAX 算法
   
      模拟一对一的博弈
   
      算法假设了两个理想对手
   
      * MAX：选择分值最高的走法（自己）
      * MIN：选择分值最低的走法（与MAX对抗）
   
      核心逻辑：通过交替递归预测从当前状态开始之后所有的回合。自己的回合选择得分最高的可能性，对手的回合选择得分最低的可能性
   
      1. 获得最大节点 / 最小节点
   
         ```python
         // RESULT(state, action) is the value of the next node
         def MIN-VALUE(state): // MAX-VALUE(state)
         	if TERMINAL(state):
         		return UTILITY(state)
         	v = Infinitely large // Infinitely small
         	for action in ACTIONS(state):
         		v = MIN(v, MAX-VALUE(RESULT(state, action))) // MAX(v, MIN-VALUE(RESULT(state, action)))
         	return v
         ```
         
         v是当前找到的最大 / 最小节点，如果下一个找到的节点比v更加大 / 小，就把v换成这个节点的值
         
         对最大值节点，遍历的时候v越来越大
         
         对最小值节点，遍历的时候v越来越小
   
      2. ab剪枝
   
         由于Minimax算法会在对局情况变得复杂的时候爆炸式增长计算次数，用ab剪枝去除一些不必要的分支
   
         核心逻辑：
   
         * 对于一个最大值节点，它会希望获得下一层所有节点的最大值，那么如果遇到一个比它已经遍历过的某个节点的值更小的节点，最大值肯定会无视这个节点，所以对于这个节点，一个最小值节点，只要它发现自己当前的值已经小于最大值已经遍历到过的值了，那么它应该立即放弃剩下的所有节点直接返回，因为它上面的最大值节点绝对不会选择它。
         * 反过来对于一个最小值节点，它希望获得下一层所有节点的最小值，那么如果遇到比它已经遍历过的某个节点的值更大的节点，它肯定会无视这个节点，所以对于它下方的所有最大值节点，如果它发现自己当前的值已经大于最小值已经遍历到过的值了，那么它可以立即放弃剩下所有节点返回。
   
         实现：
   
         ```python
         def MAX-VALUE (state, a, b):
         	if TERMINAL(state):
                 return UTILITY(state)
             v = Infinitely small
             for action in ACTIONS(state):
                 v_temp = MAX-VALUE(RESULT(state, action), a, b)
                 v = MAX(v, v_temp)
                 a = MAX(a, v_temp)
                 if a >= b:
                     break
             return v
         ```
   

## C3 逻辑智能体

能通过已知信息推算出新信息的agent

1. 命题

   命题就是某种论述，用大写字母表示

   命题之间可以通过逻辑符号连接，表示命题之间的逻辑关系

   逻辑符号：

   * 非 $\neg$ 
   * 与 $\and$
   * 或 $\or$
   * 推导 $\rightarrow$ (仅当P为真，Q为假的时候，$P \rightarrow Q$才为假)
   * 互推 $\leftrightarrow$ (仅当P，Q均为真或假的时候，$P \leftrightarrow Q$才为真)

2. 模型

   模型类似于真值表，是给所有命题赋值的一种可能情况

   知识库（KB）：agent已知的一系列语句

   Entailment：如果在任何模型中，只要$\alpha$为真，$\beta$就一定为真，则称$\alpha \models \beta$（这是a蕴含在b中）

   * 推导更像一种函数，接收两个命题并返回一个结果
   * 蕴含是一系列陈述（所有的模型）与一个具体陈述（ab关系）之间的关系

   推理：从旧有的陈述（KB）中得出新陈述的过程

   

   模型检查：判断KB是否蕴含在某个语句中

   * 首先枚举出所有可能的模型
