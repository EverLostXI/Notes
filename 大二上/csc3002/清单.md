### 所有出现的概念（感觉有用的）还有脑袋

1. 欧几里得算法gcd

2. **重载函数**

3. 函数的默认参数

4. **调用函数时发生的事**

5. 引用变量

6. **传入引用参数**

   ---

7. 库

8. cmath库

9. 斯坦福库

10. **编译过程**

11. 创建库的用户接口

12. **接口设计原则**

13. 容器/集合类

14. 库vs类的继承

15. *随机数库的实现*

    ---

16. char类型与ctype

17. **C风格的字符串**

18. **cstring库的接口**

19. **如何正确包含字符串库**

20. **字符串字面量vs字符串对象**

21. 字符串接口

22. **命令式编程范式**

23. 遍历字符串

24. **修改字符串内容**

25. 避免使用破坏性修改

    ---

26. cstdio库的接口

27. C++流

28. **标准输出流cout与插入运算符**

29. 输出运算符

30. 格式化输入

31. 标准输入流cin与提取运算符

32. **输入运算符**

33. 文件流

34. 逐字读取

35. 逐行读取（getline函数）

36. 文本文件vs字符串

37. 字符串流

38. simpio.h接口

39. filelib.h接口

    ---

40. 容器类

41. 参数化类与STL

42. 向量类

43. 初始化向量对象

44. 向量方法

45. 向量运算符

46. readEntireFile函数

47. grid类和方法

48. 堆栈类和方法

49. 队列类和方法

50. map类和方法

51. 遍历一个容器

52. 遍历顺序与迭代器

53. 集合类和方法

54. lexicon类和方法

55. **lexicon和集合的区别**

    ---

56. 枚举类型

57. 结构体

58. 结构体与类的区别

59. 类与对象

60. 类定义的格式

61. 获取方法和设置方法

62. 构造函数

63. 初始化列表

64. 类接口

65. 重载运算符

    C++中的运算符可以重载。在类定义中重载可以为类设置运算符的特殊含义

    ```C++
    Box operator+（const Box& b)
    ```

    类似于一种特殊名字的函数，像上面这个就是在Box这个类中定义的+的特殊用法

66. 定义新类的策略

67. *设计Token扫描类*

68. 用类封装程序

    ---

69. 递归

70. 递归设计范式

71. 阶乘算法

72. 斐波那契函数

73. gcd函数

74. 回文检查

75. 线性搜索

76. 二分搜索

77. **递归的思维方式**

78. 互递归

    ---

79. 汉诺塔

80. 子树

81. 子集问题

82. 生成排列

83. 生成蒙德里安画作

    ---

84. 递归的反向追踪

85. 解开迷宫

86. **解迷宫的并发性**

87. 搜索分支结构

88. **Nim游戏解**

89. **Minimax算法**

    ---

90. 排序问题

    常见排序的逻辑：

    * 冒泡排序：

      重复遍历未排序序列，一次比较两个相邻元素，如果顺序不对就把它们调换过来。这样每一轮都会确定一个最终元素。最坏和平均时间复杂度O(n^2^)，空间复杂度O(1)

    * 选择排序：

      在未排序序列中找到最小或最大元素，放在排序序列的起始位置。如此循环。时间复杂度始终为O(n^2^)，空间复杂度O(1)

    * 插入排序：

      对未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，类似整理扑克牌。最坏和平均情况时间复杂度O(n^2^)，空间复杂度O(1)

    * 快速排序：

      选择一个基准元素，通过一趟排序将未排序序列分割为独立两部分，其中一部分的元素均比另一部分小，然后对这两部分记录继续排序以达到整个序列有序

      平均时间复杂度O(n log n)，最坏情况O(n^2^)。

    * 归并排序：

      核心思想：将已有序的子序列合并。首先将区间一分为二，分裂点为平均值，然后递归地对两个子区间进行归并排序，终止条件是子区间长度为1，合并就是将两个已排序的子区间合并为一个有序区间。时间复杂度始终为O(n log n)，空间复杂度O(n)

    * 堆排序：

      将未排序序列构造成一个最大堆，此时整个序列的最大值就是堆顶的根节点

      

91. 选择排序算法

92. 计算运算次数

93. **时间复杂度（大O）**

94. **最坏情况复杂度vs平均情况复杂度**

95. 递归对复杂度的影响

96. 合并排序

97. 合并排序的复杂度

98. **标准复杂度等级**

99. 快速排序算法

100. **快速排序算法的复杂度**

     ---

101. 二进制表示

102. 内存的结构

103. 字长和地址长的关系

104. 地址长与内存大小的关系

105. **内存的分配**

106. C中的数据类型

107. 基础数据类型的宽度

     1. 整数型
        * char：1字节
        * short：2字节
        * int：4字节
        * long：64位系统上为8字节
        * long long：8字节
     2. 浮点型
        * float：4字节
        * double：8字节
     3. 布尔
        * bool：1字节
     4. 指针
        * type*：4（32位）或8（64位）字节

108. lvalue

109. **指针**

110. 声明指针

111. **指针的操作**

112. **传入指针和传入引用**

113. 指向对象的指针

114. ->运算符

115. this关键字

     每个对象都有一个特殊的指针this，指向对象本身

     对象可以通过this之神来访问自己的地址

     

116. C++中的简单数组

117. **指针与数组**

118. **指针的算术运算**

119. C字符串是指向字符的指针

120. **strcpy：危险解法**

121. *p++

     ---

122. **内存动态分配**

123. 使用delete

124. **垃圾回收**

125. **析构函数**

     在析构函数中调用delete，清除创建对象时添加的数据

126. **堆-栈图**

127. 链接对象

128. **复制对象**

129. **深/浅复制**

130. const的使用

131. 静态的成员变量

132. static的使用

     ---

133. **动态数组**

134. **链表**

135. **双堆栈**

     ---

136. 重载函数

137. **模板函数**

     在函数的实际定义前，声明一个模板

     ```c++
     template <typename T>
     ```

     T是一个类型占位符，在实际传入参数的时候之后决定类型

     函数中用起来大概这种感觉

     ```c++
     T max(T a, T b) {
         return (a > b) ? a : b;
     }
     ```

138. 用模板写排序算法

139. **类定义中的模板**

     模板类与模板函数相似，也是在类的定义前紧贴一个模板的声明

140. **实现链表队列**

141. **列表实现堆栈**

142. **实现环形缓冲区**

143. **return引用**

     原则就是：不可以返回生命周期短与函数调用的局部对象的引用，否则可能会导致返回悬空引用，导致未定义行为。

     ---

144. map类和方法

145. **给map设计方法**

146. **哈希表**

147. **哈希函数**

     核心思想：我们希望在存储的时候就得到一个对存储数据的索引，免除了重新搜索数据浪费的时间

     哈希表可以在接近O(1)的复杂度进行数据的插入，删除和查找

     哈希函数：可以将任意大小的键转变为一段固定长度的数字，用这段数字作为索引，并把值存在索引对应的位置。

148. **哈希桶**

     哈希值对应的存储值的容器就是哈希桶。为了解决哈希冲突问题，哈希桶通常不是直接存储单个键值对，而是设计成可以存储多个键值对的数据结构。当多个键映射到同一个桶时，他们会被依次添加到桶中，查找时，需要遍历链表来找到匹配的键。

149. **再哈希**

     一种扩容机制，也适用于解决哈希冲突的

     在发生冲突时，通过计算另一个哈希函数或者使用某种探测序列来寻找下一个空闲的桶。

     ---

150. 二分查找树

151. 树的递归结构

152. 移除二叉树的节点

153. 二分查找树的平衡

154. **遍历树算法**

155. **优先排列**

156. **部分有序树**

157. 栈排序

     ---

158. 实现集合

159. **字符集合**

160. **比特运算**

161. **移位运算符**

162. 抽象数据类型

     ---

163. 图表的定义和术语

164. 遍历图表

165. 深度优先搜索

166. 广度优先搜索

167. **设计一个图表的接口**

168. **参数化图表类**

     ---

169. 类的继承（概念辨析）

     ```c++
     class Animal {
         
     };
     
     class Dog : public Animal {
         
     };
     ```

     这里的public表示基类的public和protected在派生类中还会使public和protected的

     变成protected，表示基类的public和protected都会变成protected的

     变成private，则基类的成员在派生中全是private的

     public是所有人的接口

     protected是给派生类的接口

     private是只有类内部可以访问的

170. 多态：重载与覆写

171. **C++中子类的限制**

172. 避免切片

173. 虚拟关键字

174. 调用父类构造函数

175. 多继承

176. **虚拟继承**

     虚函数，使用关键字virtual

     派生类中可以重写这个虚函数

     调用虚函数时会根据对象的实际类型来决定调用哪个版本的函数

177. 解析树

     ---

178. **使用迭代器**

179. 迭代器家族

180. 实现向量迭代器

181. **回调函数**

     这是函数指针比较重要的意义：函数指针可以作为函数的返回值。这样返*回调*用的函数就是回调函数。

182. **函数指针**

183. **函数映射**

184. **给映射函数传入数据**

185. **C++中的功能性编程**

     