# C++程序设计笔记

<small>学到什么记什么</small>

## 指针与内存管理

* 地址到底是什么

  输入给内存中的解码器的数，根据这个数，解码器会选择对应的字节
  
  指针的内容，其实就是这个数，但是作为指针，这个数不会被作为一个数字使用，而是作为一个给解码器的指令

* 指针的类型是什么

  指针的类型决定了编译器要以何种方式解释指针指向的内存，这跟变量类型几乎是一样的，只不过创建指针的时候要单独说明一次指针的类型

* 指针语法

  &a;  // 取地址操作

  int* p = &a;  // 初始化指针时，数据类型后面的*表明这个p是一个指针

  *p;  // 初始化以外的情况，放在指针名前的\*表示取指针指向的内存的值的操作



### null指针

如果指针不指向任何对象，dereference它会导致未知结果，因此必须要确保它指向某个对象

没有指向任何对象的指针就是null指针，值为0

可以在使用指针之前检查它是否指向某个对象

if ( pi && ... )只有在pi是一个非零值时，结果才会是true


* 想调用指针指向变量的类内置的方法时用箭头
例：vector.empty() 变成pv->empty()

## 文件的读写

先要include fstream

ofstream outfile("seq_data.txt")
* 声明outfile的时候，如果文件不存在，则会自动产生一个这个文件。

如果想要把新数据加到文件末尾，可以使用追加模式
ofstream outfile("seq_data.txt", ios_base::app )

确认文件是否成功打开：if（！outfile）
文件成功打开时，outfile的值为true

infile同理

如果是iofile，要以追加模式打开的话，传入的参数是ios_base::in|ios_base::app

* 以追加模式打开文件之后，文件位置会位于末尾，必须先重新定位至文件起始处。seekg()

# 面向对象的编程风格

## 函数
函数必须定义四个部分
1. 返回类型
2. 函数名
3. 参数列表
4. 函数体

要为用户可能犯下的错误做足应对措施

向函数中注入参数的时候会把注入的变量复制进去，所以有时候最好使用引用，这样注入的就是变量的地址。
pass by reference
用引用作为参数的意义主要是
1. 得以直接对传入的对象进行修改
2. 降低复制大型对象的额外负担

引用与指针之间最大的差别是指针可能不指向某个实际对象，reference则必须代表某个对象。

### 作用域
* 局部变量：函数执行期间暂时位于堆栈上，因此函数内创建的变量也位于堆栈上。当函数执行结束，局部变量也不复存在。
* 因此不要对局部变量以指针或者引用的寻址操作返回，这样会导致不必要的问题，应该用传值的方式返回。

为对象分配的内存，其存活时间成为储存期，或者范围。其存活区域成为该对象的作用域（scope）
* 如果对象在函数内声明，则具有local scope；如果在函数外声明，则具有file scope
* 太依赖filescope不太好，因为这样容易让函数难以在其他环境中重用，并且难以修改，因为除了了解函数体，我们还得了解filescope中定义的对象的工作逻辑。
*一般会以“参数传递”的方式作为函数间的沟通方式，而不是直接把对象定义于filescope中


### 动态内存管理
一般来说的变量都是存在静态存储区的（static data）。但是我们也可以手动分配堆（heap）上的内存。

堆就像是一个原始的架子，你可以往上面放东西，但是怎么放你得自己决定，而且你还得手动清理，要不然你放的东西就会一直留在那里。

* 分配堆上的内存：
int* pi = new int；
这里我们先在堆上创建了一个int类型的数据，再把它的地址赋给了pi
也可以直接初始化：int* pi = new int（具体数字）；

同理我们可以在堆上创建一个数组：
int* pi = new int [size]；
这里是一个动态数组，我并没有初始化这个数组的长度。

* 清理已经分配的内存：
delete pi；
这样就会把pi指向的对象给删除
如果是一个数组，要删除数组中的所有对象，则是
delete [] pi；
**编译器会帮我们检查pi是否非零**

什么时候会需要我手动分配堆上的空间呢
* 静态存储区的数据大小必须在编译的时候确定，但是堆的数据大小可以在运行时动态决定。
* 动态数组：我们可以在初始化数组的时候不给定它的长度，可以把长度设为一个变量，变量在程序运行时由用户输入


### 关于默认参数
1. 需要设置默认参数时，不能以引用作为参数，因为引用没法设置为0，它必须指向某个具体的对象
2. 默认值的解析操作从最右边开始进行，如果为一个参数提供了默认值，这一参数右侧的所有参数也都必须具有默认值
3. 默认值只能指定一次，要么在函数声明处，要么在函数定义处（习惯而言，会把默认值放在函数声明处而非定义处）

### 局部静态对象
有时候我们不希望每次调用同一个函数时都要把之前算过的东西再算一遍，但是局部变量又会在函数结束的时候被清除，而全局变量又会打乱不同函数之间的独立性，过于冒险，这种时候就可以使用局部静态对象

static vector<int> elems;

局部静态对象所处的内存空间会**一直存在**，而不是在每次调用时才重新创建又清除，因此我们也可以直接返回局部静态对象的地址

### inline函数
被声明为inline的函数会在被“调用”的位置直接把函数体复制粘贴过去（类似于头文件的感觉）

一般是需要被频繁调用的体积小的函数会被声明为inline，否则，容易造成程序体积膨胀

如果一个函数由很多小函数构成，也可以使用inline，避免了不停跳转带来的损失

### 重载函数
可以声明一系列名字相同但是参数列表不同的函数，在调用的时候编译器会自动根据传入的参数类型决定调用的函数

### 模板函数
我们可以待定函数参数的数据类型，每次用户输入的时候要自己明确数据类型
template <typename elemtype>
void display( const string &msg, const vector<elemtype> &vec>
* 这里关键字typename表示elemtype只是一个占位符

* 如果我们希望函数具有多种实现方式，可以使用重载，如果希望代码主体不变，仅仅改变用到的数据类型，可以使用函数模板。

### 函数指针
就是“指向一个函数”的指针
与普通指针不同的是，函数指针必须指明函数的返回类型及参数列表（函数的特征）

const vector<int>* (*seq_ptr) (int);
这里的意思是，*seq_ptr是我们要的函数指针，指向的返回类型是const vector<int>*，参数列表是int

### 设定头文件
我们把需要的函数的声明放入头文件中，把函数的定义放到其他程序文件中。
* 只有一个例外，那就是inline函数，由于每次调用编译器都必须得到inline函数的定义，inline函数的定义也必须包含在头文件中



## 泛型编程风格
STL（Standard Template Libirary）包含两个部分
1. 容器：vector，list等类
2. 泛型算法：用于操作这些容器的算法，



### 指针的算数运算
直接对指针代表的地址的值进行运算
与数组的下标是同一个原理：
数组的地址只记录数组的第一个元素的位置，后面的元素紧跟在第一个元素之后。
* 在指针算数运算中，会把指针所指的类型的大小考虑进去。
假设数组中的数据类型为int，array+2便是array的地址加上两个整数元素的大小。
