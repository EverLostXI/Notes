# ECE2050数字电路

## 一 数字系统 C2

1. 进制转换

   4， 8， 10， 16进制之间的转换都通过2进制作为中继

   **10进制转二进制：整数部分除2取余，倒序排列；小数部分乘二取整，顺序排列**

   

2. 原码

   把二进制数的第一位作为这个数的符号，其他位数就是这个数的绝对值

   **注意：二进制第一位是1，所以二进制数第n数位的值是 $2^{n-1}$ 而非 $2^n$**

   问题：

   * 除了两个正数间的加法，对其他数的运算会产生各种问题
   * 0有两种表示方式（+0和-0）

   

3. 补码

   将一个数所有位置的值反转后+1，得到这个数的**相反数**表示

   * 0只有一种表示方法
   * 可以直接进行补码运算

   **补码的最小负值的表示方法与原码的最大值相同**

   例：4096原码：1 0000 0000 0000；反转后+1得到 -4096补码：1 0000 0000 0000

   

4. 补码运算

   只要运算结果没有超出补码的范围，就可以直接进行运算**（加减法计算时两个数的数位必须相同）**

   **规则：异号相加一定不会溢出；同号相加如果符号没变就没有溢出（多的进位舍弃）**

   * 乘除法都可以先对两个数的绝对值直接进行运算，再根据同正异负的原则修正结果的符号

   除法：把被除数不断加上除数的相反数，每次加就给商加一，**每次加的进位要舍去**

5. 二进制小数

   固定点数：Ua.b（无符号）或Qa.b（有符号）。a是小数点前的数位（包含第一位的符号），b是小数点后的数位

   浮点数：小数点固定位于最大的位数的右侧，类似于科学计数法

   （例：$228_{10}=1100100_{2}=1.11001\times 2^7$)<img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-09-10 232934.png" alt="Screenshot 2025-09-10 232934" style="zoom:80%;" />

   上图是IEEE754规范的单精度浮点数（float）的格式

   <small>（好像这个格式有不少神秘问题比如0.1 + 0.2 = 0.30000...04，不知道怎么回事，回头去查证下）</small>

   * Biased Exponent（偏移编码指数）：真实的指数 + 固定偏移量，变成一个永远是正数的值

     这是为了包含负数指数，但是直接用补码会导致比较操作变得复杂。

     8位编码可以储存0 ~255，而全0给到0和非正规数，全1留给NaN和无穷，剩下1 ~ 254，

     变成从-126 ~ +127（想得到真实指数只需要**存储值 - 127**（偏移量））
     
     

6. BCD码（Binary Coded Decimal）

   将每一个十进制数用二进制（4位）表示

   * BCD码加法：按位（4位）相加，如果某位的和大于9，则在这一位上加6，就可以得到正确的BCD码，随后在下一位进1

     为何加6：4位二进制数可以表示15个数，而BCD码只表示1 ~ 9，所以当超过9，加6就可以回到有效的BCD码范围内
     
     

7. 格雷码

   每两个相邻的数之间，用来表示它们的二进制数只有一个位数的区别（电路中4位的变化无法同时发生，因此可能导致错码）

   * 格雷码与二进制码的相互转换

     <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-09-11 010456.png" alt="Screenshot 2025-09-11 010456" style="zoom:80%;" />
     
     格雷码是一种*非加权值数制*：它的每个数字的表示方式不是简单的由每位上的数值按权重加和而成的
     
     

8. 错误码

   1. 奇偶校验位

      工作原理：以奇校验为例，在原始数据后增添一位数据，如果原始数据中的1有奇数个则增添0，否则增添1。偶校验正好与奇校验相反。

      缺点是无法检测偶数个比特出错的情况

   2. 循环冗余校验（CRC）

      <big>**注意：这里的除法用的是模二除法！！！**</big>

      工作原理：首先与接收方预先约定一个数（生成多项式），在原始数据末尾增添生成多项式数位-1个0，然后将这个数除以生成多项式，最后将增添的0替换为除法的余数（CRC校验码），就可以发送给接收方。

      接收方获得数据后将数据除以生成多项式，如果结果不为0，则发生了错误

      可以检测出多比特位的错误。缺点是没法直接纠正错误（有些编码方式同时还能纠错）

      

## 二 逻辑门 C3

1. 逻辑门

   性质：真值表 + 时序图

   基础逻辑门的逻辑表达式：(+是或，乘是与，$\oplus$是异或)

   NOT：$X=\overline A$

   AND：$X=AB$

   OR：$X=A+B$

   NAND：$X=\overline {AB}=\overline A +\overline B$

   NOR：$X=\overline {A+B}=\bar A \bar B$

   XOR：$X=A\oplus B=\bar AB+A\bar B$

   XNOR：$X=\overline {A\oplus B}=AB+\bar A\bar B$

   运算规则：

   ![Screenshot 2025-09-15 163630](D:\大学\笔记\大二上\用到的图片\Screenshot 2025-09-15 163630.png)

   

2. 逻辑电平

   1. 噪声：传输过程中导致信号变化的扰动

      * 为了减少甚至避免噪声的影响，输出信号和输入信号都有一定探测范围

   2. 噪声容限：输出的高电平范围的最小值 与 输入的高电平范围的最大值 的差值叫高噪声容限

      反过来，输出的低电平的最大值 与 输入的低电平的最大值 的差值叫低噪声容限

   3. 缓冲器性质：~~红石中继器？~~

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-09-18 185745.png" alt="Screenshot 2025-09-18 185745" style="zoom: 50%;" />

      <small>~~以防我又读不懂了~~：横轴是输入的电压，纵轴是输出的电压。理想状况是随着输入电压上升，输出电压稳如老狗，直到在输入电压达到V~DD~的一半的瞬间，输出电压可以直接达到V~DD~的最大值。然而实际上随着输入电压上升输出电压也会缓慢上升，等过了阈值输出电压的上升实际上也是有一定梯度的，因此.....具体数据自己看图吧。</small>

   4. 禁区：输入能检测的高电平最小值与低电平最大值之间的区域，无法确认为高电平或是低电平

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-09-18 184642.png" alt="Screenshot 2025-09-18 184642" style="zoom: 67%;" />

      <small>V~O/I~ ~H/L~：输入/输出 的 高/低电平 范围</small>  <small>V~DD~：正电源电压</small>  <small>NM~H/L~：高/低噪声容限</small>

3. V~DD~：7080年代的时候一般为5v，后面降低了（省电，防止烧件）

   要注意不同原件的工作电压不同，小心不要把元件烧了



## 三 布尔代数与逻辑化简 C4

1. 组合电路与时序电路：

   电路性能指标：功能性能 / 时间性能

   数字逻辑电路分为两种结构：

   1. 组合电路：电路中无记忆单元，无反馈延迟通道，输出仅由当前输入决定（第五章）

   2. 时序电路：有记忆单元，输出由当前或者历史输入决定（第六章）

   组合电路要满足的规则：

   1. 组成组合电路的每一个元件都只能是组合电路
   2. **每个结点要么是整个电路的输入，要么连接到一个其它元件的输出。**
   3. 电路中不存在环路

   

2. 布尔代数定理

   用于简化计算

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-09-22 160944.png" alt="Screenshot 2025-09-22 160944" style="zoom: 40%;" />

   具有对偶性：把0和1，and和or互换，定理仍然成立

   

3. 布尔运算

   基本运算：

   1. 加和，等同或运算

   2. 乘算，等同与运算

   3. 交换律、结合律和分配律

   具体的公式在第一节课的笔记里（那12条公式里面有好多是根据对偶性得出的）

   后三条的证明：可以完美归纳，可以用其他定理推导而出

   

4. 德摩根定律（代数）

   $\overline {XY}=\bar X + \bar Y$：非（X与Y）= 非X 或 非Y

   $\overline {X+Y}=\bar X\bar Y$：非（X或Y）= 非X 与 非Y

   简单来说，把上划线切开，就反转符号

   

5. 代数化简逻辑表达式

   用前面的12条

   比较重要的是后3条：

   1. $A+AB=A$

   2. $A+\bar AB =A+B$

      这两条用于消除冗余项

   3. $(A+B)(A+C)=A+BC$

      这个其实拆开就是这样，重点是可以反过来用。

      

6. 标准逻辑表达式：SOP与POS

   * 任何布尔等式都可以写成标准形式

   * 把任何式子补成标准式的方法：

     $A+\bar A=1$，所以可以把缺字符的最小项乘1得到完整的最小项

     SOP：$AB = AB(C+\bar C)=ABC+AB\bar C$
     
     POS：$(A+B) = (A+B+C\bar C)=(A+B+C)(A+B+\bar C)$
     
     **记得用这个：**$A+BC=(A+B)(A+C)$

   1. 基本概念：

      字符：变量，或者其补

      蕴含项：几个字符的积

      最小项：**包含所有变量**的积

      最大项：**包含所有变量**的和

   2. SOP（和之积式 / 或与式）

      先得到这个表达式的真值表，随后取出真值表中输出为1的行，把每一行对应的最小项加起来即可。

   3. POS（积之和式 / 与或式）

      取出真值表中输出为0的行，把每一行对应的最大项乘起来即可

      <big>**注意：对POS来说真值表输入为0的是真输入为1的是否**</big>

   4. 化简技巧

      * 任何项都可以复制（A = A + A），可以用来消除冗余项。

   5. **POS与SOP转换**

      * 代数方法：

        POS => SOP：直接拆开

        SOP => POS：A + BC = (A + B) (A + C)	A可以是一段代数式，然后里面继续拆、

      * 卡诺图（如果还需要顺便化简）

        圈1和圈0的区别，除此之外还需要把输入给反向一下。

7. 卡诺图

   行和列都以格雷码排开，这样相邻两项就只有一项不同
   
   化简规则：
   
   1. 把相邻的1圈起来就是化简，圈只能是矩形，且里面的1的个数必须是2的倍数
   
   2. 卡诺图的边缘是左右，上下相连的
   
   大于4变量的卡诺图，可以看作是多维的，在相同位置的项也可以圈起来，不过必须也符合化简规则。
   
   * 带有随意项（Don't care）的卡诺图化简：
   
     只有当一个X可以帮助圈出一个完整的化简圈时，才圈上这个X
   
   
   

## 四 组合电路设计 C5

1. 基础组合电路

   用与门和或门搭的

   XOR和XNOR也可以用AND和OR实现（公式）

   

2. 奇偶校验码

   **偶校验码就是全部输入的和最低位上的数字**

   奇校验码：$Y=\overline{A\oplus B\oplus C...}$	偶校验码：$Y=A\oplus B\oplus C...$

   <small>~~设计逻辑：奇数+奇数=偶数；偶数+偶数=偶数；奇数+偶数=奇数~~</small>

   设计逻辑：XOR就是不进位二进制加法，所以把所有输出全部异或一遍，就是得到所有输出的和的最低位，那么这个位为0就是偶数，为1就是奇数

   

3. 组合电路与代数表示

   任何逻辑表达式都可以搭出对应的电路

   将逻辑表达式化简为最简形式之后的电路也对应最简（使用的逻辑门最少）

   带有随意项的

   

4. NAND与NOR的性质

   四个基本逻辑门之间可以相互转换（德摩根定律）

   任何逻辑门都可以只用NAND或者只用NOR表示

   NAND = negative-OR （$\overline {AB}=(\bar A+\bar B)$

   NOR = negative-AND （$\overline {A+B}=\bar A\bar B$）

   

5. 德摩根定律

   推泡泡（对偶逻辑门转换）：把一个门的输入或者输出的泡泡挪到它的另一端，再把它的逻辑换成对偶的（AND <--> OR）

   从最终的输出的泡泡往回推，泡泡相遇可以抵消



## 五 组合电路部件 C6

1. 半加器与全加器

   1. 半加器

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-10-15 153952.png" alt="Screenshot 2025-10-15 153952" style="zoom:50%;" />

      XOR输出本位，AND输出进位

      **可以看到XOR逻辑可以表示二进制加法**

      

   2. 全加器

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-10-15 154230.png" alt="Screenshot 2025-10-15 154230" style="zoom:50%;" />

      全加器实际上是两个半加器**和一个或门**的组合

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-10-15 154326.png" alt="Screenshot 2025-10-15 154326" style="zoom:50%;" />

      逻辑是：先计算两个数的和与进位，随后再计算这个和与上一个进位的和和进位。

      ~将第一个半加器得到的和与输入的进位作为下一个半加器的两个输入得到最终三个数的总和，再将两个半加器的进位或作为全加器的进位（两个进位不会同时为1）~

      串联多个全加器可以得到并行加法器

      例：级联两个4位加法器实现8位数相加

      低位加法器进位输入（C~0~）接地，进位输出（C~4~）连接到高位加法器。

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-10-15 160424.png" alt="Screenshot 2025-10-15 160424" style="zoom:50%;" />

      

   3. 并行加法器

      1. 行波进位加法器

         直接串联的方式，由于下一位的计算需要等待上一位的进位，整个电路的传播延迟会很大

      2. 超前进位加法器

         想办法直接算出某一位有没有进位

         公式：C~out~=G+P·C~in~

         逻辑：对于某一位数，有AB两个输入，以及上一位的进位C。接下来统计它能进位的情况：第一个是AB都为1，第二个是输入的进位为1，并且AB中有一个为1。公式中，第一个情况就是G，第二个情况是P·C~in~。C~in~就是上一位的C~out~，所以这是个层层递进的算法，但是最终确实可以只通过初始输入和进位来算出每一位的进位。
         
         电路：G~n~=A~n~B~n~; P~n~=A~n~+B~n~; 这一位的C~out~就是下一位的C~in~
         
         

2. 比较器

   * 判断相等：用XNOR，如果两位相等输出1。对于更多位的二进制数，只需要按位比较，再把每位的结果进行与运算即可。
   * 判断大小：从高位向低位判断，如果相等，则判断下一位，否则可以直接输出结果。
   * 多个比较器可以串联在一起来比较更大的数

   IC：74HC85

   ​	四位二进制输入，两个数字，三位串联输入（上一个比较器判断的大小），三位输出（大于还是小于）

   ​	<img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-01 235751.png" alt="Screenshot 2025-11-01 235751" style="zoom:50%;" />

   

3. 编码器与解码器

   这个“码”指的就是非二进制数，所以编码器把二进制数转为非二进制数，而解码器把非二进制数转为二进制数

   1. 编码器：将一位输入（表示的十进制数）转换为多位二进制数输出

      设计逻辑：每个输出位对应一个或门，如果一个十进制数对应的二进制数在这个位是1，则把这个输入或到这一位的输出

      最高位编码器：只输出最大的输入数对应的二进制数

      设计逻辑：真值表最高位以下的项都是随意项

   2. 解码器：将二进制输入转换为十进制输出

      设计逻辑：每个输出都是一个与门，把输入的数每一位对应的1或0接入这个与门

      * **用解码器和或门可以表示任意标准逻辑表达式**
      * 解码器每一位输出都对应一个二进制输入，也就对应到真值表上的一行，把需要的行或起来就是
      
      IC：74HC154 四到十六解码器
      
      2个控制输入，如果同为低，则输出的1为高，否则输出的1为低
      
      4个输入，16个输出.
      
      可以将两个串联起来形成五到三十二解码器
      
      串联的时候，将两个控制输入作为第五位数，低级的元件直接输入，高级的元件输入反转
      
      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-02 122859.png" alt="Screenshot 2025-11-02 122859" style="zoom: 67%;" />

4. 多路选择器MUX与多路分配器deMUX

   1. 多路选择器

      通过输入控制信号，来控制具体哪一路的输入可以通过元件

      输入的控制信号是一个二进制数，它的表示范围决定了数据输入可以有几路

      电路逻辑：每一路输出最后都是一个与门，这个与门除了接入这一路的数据输入以外，还要接入对应位置的控制输入，比如第二路的就要接入10的控制信号

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-02 124229.png" alt="Screenshot 2025-11-02 124229" style="zoom: 50%;" />

   ​	两位控制输入的mux也可以看作是三个一位控制输入的mux串联

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-02 124201.png" alt="Screenshot 2025-11-02 124201" style="zoom: 50%;" />

   ​	用多路选择器也可以表示标准逻辑表达式

   ​	辨析：多路选择器与解码器表示逻辑表达式的方法

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-02 124754.png" alt="Screenshot 2025-11-02 124754" style="zoom: 50%;" />

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-02 124846.png" alt="Screenshot 2025-11-02 124846" style="zoom:50%;" />

   ​	mux：通过给控制输入指定信号来控制输出的逻辑表达式

   ​	解码器：通过把输出中需要的项或起来控制输出的逻辑表达式

   2. 多路复用器：

      一位数据输入，多位控制输入

      控制输入决定数据输入要通过哪一位输出

5. 延迟

   延迟有两种：

   1. 传播延迟：从输入到输出正确信号之间的延时
   2. 污染延迟：从输入到输出信号开始发生变化的延时

   产生延迟的原因：

   * 电路中电容和电阻的阻碍
   * 光速的限制

   t~pd~和t~cd~有差异的可能原因：

   1. 上升延迟与下降延迟不同
   2. 有多个输入或输出，有些可能比其他的更快
   3. 电路温度越高速度越慢

   最长路径与最短路径：

   计算一条路径的延迟只要把这条路上所有元件的延迟加起来就好

   

   * 毛刺

     表现：一次输入变化导致输出变化多次（毛刺）

     修复：卡诺图打圈
   
     

## 六 时序电路设计 C7

1. 状态元件

   名词解释：

   * 状态：与电路后续行为有关的所有历史输入
   * 锁存器Latch
   * 触发器Flip-flop
   * 同步时序电路：把触发器作为时钟的时序电路

   特点：

   1. 事件发生有顺序
   2. 有缓存
   3. 可以把输出重新输入来存储信息

   

2. 双稳态电路

   锁存器和触发器的基本组成单位

   ![Screenshot 2025-11-19 213406](D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-19 213406.png)![Screenshot 2025-11-19 213406](D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-19 213407.png)

   这两张图其实是同一个电路

   

3. 锁存器 Latch

   1. SR 锁存器
      有两种SR锁存器，分别为Active-LOW型和Active-HIGH型。

      * Active-HIGH：

        组成电路的逻辑门是**NOR**，基础状态是S和R同为0的情况

        当R被设置为1时，输出为Reset，即Q为0，QN为1

        当S被设置为1时，输出为Set，即Q为1，QN为0

        由于高电平控制输出状态改变，名称为Active-HIGH

        <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-19 220833.png" alt="Screenshot 2025-11-19 220833" style="zoom:67%;" />

        * **注意：S与$\bar Q$**对应，R与Q对应

      * Active-LOW：

        组成电路的逻辑门是NAND，基础状态是S和R输入都为1的情况，这种情况下电路的输出会保持当前状态

        当R设为0时，输出会被设置为Reset状态

        当S设为0时，输出会被设置为Set状态

        由于是低电平控制输出状态改变的，名称为Active-LOW

        

   2. D 锁存器
      在SR锁存器的基础上，我们可以在前面添加两个与门，分别接上S和R，再接上同一个开关。这样如果开关关着，无论SR输入是什么，接入实际电路的两个输入都会是0（或者1，如果用NAND的话）

      如果把这个开关换成时钟刻CLK，再把S和R用一个D输入控制，只不过R是DN，这样就可以只用一个输入控制输出了，这就是D锁存器

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-19 222409.png" alt="Screenshot 2025-11-19 222409" style="zoom:67%;" />

      **注意：S对应的是反向输出**
      
      

4. 触发器 Flip-Flop

   1. D 触发器

      逻辑上：在D锁存器的基础上，但是CLK输入变成检测时钟刻的上升沿，每当时钟刻由低变高时，会有短暂的输入窗口，这个时间内的D的值可以用来控制输出‘

      实际电路设计：

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-19 222645.png" alt="Screenshot 2025-11-19 222645" style="zoom:67%;" />

      **这里是利用了非门的延迟，CLK上升沿到来前L1是通的，上升沿到来的短暂瞬间L2也会通，在非门延迟之后L1关闭，完成一次信号输入**

   2. JK 触发器

      基本逻辑跟SR锁存器很像，基础状态是JK都为0的时候，当J为1，输出设为set；当K为1，输出设为reset。唯一不同的是，JK同为1的情况现在会让输出反转。同时它是一个触发器，只有在时钟刻上升沿输入才会对输出产生影响

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 165856.png" alt="Screenshot 2025-11-20 165856" style="zoom: 50%;" />

5. 使能触发器
   在D触发器的基础上添加一个MUX，作为开关，当选择信号输入，触发器保持它的当前信号，当开关打开，触发器接受D的信号

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 165955.png" alt="Screenshot 2025-11-20 165955" style="zoom: 67%;" />

6. 可重置触发器
   在D触发器的基础上，增加一个reset开关，当这个开关设置为1时，触发器的输出被强制设置为0
   可重置触发器有两种

   1. 同步型
   仅在时钟刻上升沿进行重置

   2. 异步型
      reset开关被设置为1的瞬间就会把输出设置为0 

7. 可设置触发器

   在D触发器的基础上，增加一个set开关，当这个开关设置为1时，触发器的输出被强制设置为1

   * **注意：D信号总是受CLK影响！**



## 七 移位寄存器 C8

寄存器的两大作用：数据存储、数据转移

1. 数据输入和输出的模式有两种
   1. 序列：随着CLK跳动逐级传播
   2. 并列：可以同时输出每一位数据

   
   
2. 各种寄存器

   1. 序列进，序列出
       把多个寄存器输入与输出串联在一起，接入同一个时钟刻，就得到了串联寄存器

     <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 180613.png" alt="Screenshot 2025-11-20 180613" style="zoom:50%;" />

     波形图横轴为时间，正方向向右

     <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 182033.png" alt="Screenshot 2025-11-20 182033" style="zoom: 50%;" />

   
   
   2. 序列进，并列出
       <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 182328.png" alt="Screenshot 2025-11-20 182328" style="zoom: 50%;" />
   
       
   
   3. 并列进，序列出
       <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 182627.png" alt="Screenshot 2025-11-20 182627" style="zoom: 50%;" />
   
     上方的移位/加载开关控制着Q~0~以外的几个寄存器，是输入上一位寄存器的输出还是输入外部信号
   
   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-23 191352.png" alt="Screenshot 2025-11-23 191352" style="zoom: 50%;" />
   
   4. 并列进，并列出
       <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 183731.png" alt="Screenshot 2025-11-20 183731" style="zoom: 33%;" />
   
     纯粹
   
   
   
   5. 双向移位寄存器
       似乎可以当多路选择器用（那为什么不直接用多路选择器）
       
         <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 202114.png" alt="Screenshot 2025-11-20 202114" style="zoom:50%;" /><img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-23 183811.png" alt="Screenshot 2025-11-23 183811" style="zoom: 55%;" />
       
       这个左/右开关的原理很像并列进序列出那种寄存器的加载/移位开关，都是选择这一位的输入信号，这里选择的是“前一位的输出”和“后一位的输出”
       
       
   


3. 移位寄存器的应用

   1. 可控的信号延时
        由于数据在寄存器内会每隔一个CLK向后移动一位，一个序列进，并列出的寄存器可以当作一个固定延时器

        <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 205445.png" alt="Screenshot 2025-11-20 205445" style="zoom:50%;" /><img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-20 205540.png" alt="Screenshot 2025-11-20 205540" style="zoom: 50%;" />

        

   2. 单稳态触发器 One-Shot Logic
        利用RC电路，将一个窄脉冲延长为一个固定长度的宽脉冲
        输出脉冲的宽度由RC电路的性质决定

        <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-21 181045.png" alt="Screenshot 2025-11-21 181045" style="zoom:67%;" />

        

   3. 串行/并列数据转换器 S/P Data Converter
        可以将串联输入转换为并列输出，或者把并列转为串联

        用来减少数据传输通道的数量

        <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-21 181145.png" alt="Screenshot 2025-11-21 181145" style="zoom: 70%;" /><img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-21 182232.png" alt="Screenshot 2025-11-21 182232" style="zoom: 60%;" />

        电路分析：电路接收一个序列输入，这个输入分别进入一个SIPO寄存器中和一个PIPO寄存器的控制电路中

        在控制电路中，首先用JK触发器作为开关开启时钟刻，随后生成的时钟刻信号输入给一个8分频计数器，每当经过8个时钟刻就会产生一个高电平，这个高电平经过与门会在下一个时钟刻输入给装有数据信号的PIPO寄存器，让它输出，同时复位JK触发器和8分频计数器

        

   4. UART (Universal Asynchronous Receiver Transmitter)
      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-21 195516.png" alt="Screenshot 2025-11-21 195516" style="zoom: 50%;" /><img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-21 203530.png" alt="Screenshot 2025-11-21 203530" style="zoom:50%;" />

   5. 键盘解码器

      作用：检测键盘矩阵哪个位置的按键被按下，并将其位置编码为一个6位数字代码

      原理：用一个8位环形计数器循环扫描每一行，这个8位环形计数器中有一个0一直在循环跳动，轮流让每一行的信号从1变为0；每一列的信号初始都为1，当键盘被按下，这一位上的行与列被连接，当这一行被变为0时，对应列也会被变为0，把行列的所有信号用8位编码器编码，就得到了一组6位代码，用来表示被按下的键的坐标

      此外还有两个单稳态触发器用于消除电路抖动

4. 计数器

   1. 约翰逊计数器

      串联D触发器，最后一位的**反向输出**连接给第一位的输入

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-21 204426.png" alt="Screenshot 2025-11-21 204426" style="zoom:50%;" />

      由于这个特性，计数器内的数位会被**固定**为下图情况

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-21 223530.png" alt="Screenshot 2025-11-21 223530" style="zoom: 67%;" />

      可以这么去理解：$\bar Q_3$的值会从第一位开始逐渐充满整个计数器的每一位，而当充满时，$\bar Q_3$又会反转，重新开始充满每一位。

      **模数modulus**：

      计数器的独特状态的数量。
   
      一个约翰逊计数器的模数为2n，n为这个计数器内寄存器的位数。e.g. 图中有4位寄存器，因此整个电路有8个状态，因此模数为8
   
   2. 环形计数器
   
      串联寄存器，最后一位的输出接到第一位的输入
   
      单纯的在回路中循环一个数字的结束器
      
      模数为n

## 八 有限状态机 C9

1. 同步时序逻辑电路

   设计规则：

   1. 电路中所有元件要么是寄存器，要么是组合元件
   2. 整个电路中至少存在一个寄存器
   3. 所有寄存器依赖同一时钟刻
   4. 每个环路中都至少存在一个寄存器

2. 有限状态机（FSM）

   1. 有限状态机有两种：

      1. Moore状态机

         输出仅与电路当前状态有关~（输入仅用于注入状态）~

         <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 161932.png" alt="Screenshot 2025-11-22 161932" style="zoom:67%;" />

      2. Mealy状态机

         输出与电路当前状态，以及当前输入有关~（输入本身可以决定输出）~

         <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 162102.png" alt="Screenshot 2025-11-22 162102" style="zoom:67%;" />

   2. 设计有限状态机的步骤

      1. 确认输入输出

      2. 绘制 状态转换示意图

      3. 填写 状态转换表 和 输出表

         * 对于Moore状态机，这两个表是分开的
         * 对于Mealy状态机，这两个表要放在一起考虑

      4. 为电路状态编码

      5. 用状态编码重写 状态转换表 和 输出表

      6. 写出每个状态和每个输出的的逻辑表达式

      7. 画电路图

         1. Moore状态机示例：交通灯中枢

            目标：

            <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 163257.png" alt="Screenshot 2025-11-22 163257" style="zoom: 33%;" />

            我们希望交通灯在没车的时候能自动流转，任意方向有车则此方向保持绿灯直到回到没车状态

            1. 确认输入输出

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 163402.png" alt="Screenshot 2025-11-22 163402" style="zoom: 33%;" />

            2. 状态转换图

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 165619.png" alt="Screenshot 2025-11-22 165619" style="zoom: 33%;" />

               每一个圈表示一个状态，箭头表示状态间的转换及条件

            3. 状态转换表

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 170022.png" alt="Screenshot 2025-11-22 170022" style="zoom: 33%;" />

               这张表与状态示意图是一致的

            4. 状态编码

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 170206.png" alt="Screenshot 2025-11-22 170206" style="zoom:40%;" />

               **为状态编码**，注意这里要把S（0\~3）替换为右侧对应的编码，这样才能将每个状态对应到S~1/0~的值

               然而状态还不是我们实际要输出的东西

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 170304.png" alt="Screenshot 2025-11-22 170304" style="zoom: 50%;" />

               实际要输出的是信号灯，**因此我们同样为信号灯编码并与状态对应**

            5. 逻辑表达式与电路图

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 170340.png" alt="Screenshot 2025-11-22 170340" style="zoom:50%;" />

               根据上方的图，可以得到S'~1~与S'~0~的逻辑表达式，以及每一位输出的逻辑表达式

               **逻辑表达式**：T~A~，T~B~，S~0~，S~1~都可以视作输入，而S~0~'，S~1~'才是输出。
               
               state register会根据你状态的数量变化，直接用D触发器就行。
               
               下图就是我们最终得到的电路输出的波形图示例

            <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 170512.png" alt="Screenshot 2025-11-22 170512" style="zoom:50%;" />

            

            * 状态编码形式

              1. 二进制编码

              2. 单热编码

                 每个状态的对应编码中都只有一位为1，例：对于四个状态，可以编码为0001，0010，0100，1000

                 * 存储状态需要更多触发器

                 * 通常状态表达式和输出表达式会更简单

            

         2. Mealy状态机示例：微笑蜗牛

            目标：<img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 224225.png" alt="Screenshot 2025-11-22 224225" style="zoom: 33%;" />

            这只可怜的小蜗牛爬过一些随机的0和1，每当它爬过的前两位数字为01时，它就会苦笑一下<small>~~就像你我的人生~~</small>

            1. 确认输入输出

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 224526.png" alt="Screenshot 2025-11-22 224526" style="zoom:50%;" />

               先读图：Mealy状态机示意图弧线上左边的数字表示当前输入，右边的数字表示当前输出

               Moore实际上是把输出与状态绑定了。对于Mealy状态机而言，由于输出由输入和状态共同决定，它的状态会更少

            2. 编码与逻辑表达式

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 231111.png" alt="Screenshot 2025-11-22 231111" style="zoom:50%;" />

               **辨析**：Moore和Mealy到底有区别在哪

               * Moore是先用当前状态和数据输入作为输入得到下个状态的表达式

                 再**仅仅**用当前状态来表示每个输出
         
               * Mealy是直接用**当前状态和输入**来表示每个输出
               * 可以说，这两个东西的输出跟输入肯定都是有关系的，然而，Moore的输入**只能直接决定下个状态**，而Mealy的**可以直接决定输出**
            
               同一个效果的电路，无论用Moore实现还是Mealy实现都是可以的，但是会在电路复杂度上有区别，且输出时值不太一样。

            3. 电路

               <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-11-22 234227.png" alt="Screenshot 2025-11-22 234227" style="zoom:50%;" />
         
            4. 出结果时间
         
               * Mealy状态机检测到01的同时就会输出正确结果
               * Moore状态机要到检测到01的下一个时刻才会输出正确结果
            
            5. 延迟
            
               1. 寄存器信号输入时机的限制
            
                  * 设置时间t~setup~：在CLK信号到来前，输入信号需要保持稳定的时间
            
                  * 维持时间t~hold~：CLK时间到来后，输入信号需要继续保持稳定的时间
            
                  * 孔径时间t~a~：CLK来临前后需要输入信号维持稳定的总时间
            
                    <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-18 170820.png" alt="Screenshot 2025-12-18 170820" style="zoom:40%;" />
            
               2. 寄存器输出延迟
            
                  * 传播延迟t~pcq~：收到CLK信号后输出信号能保持稳定的时间
            
                  * 污染延迟t~ccq~：收到CLK信号后输出信号开始出现波动的时间
            
                    <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-18 170929.png" alt="Screenshot 2025-12-18 170929" style="zoom:50%;" />
            
               3. 时钟周期限制
            
                  1. 设置时间限制
            
                     为了让电路正常运算，需要在一个时钟信号周期内留有足够的时间
            
                     这个时间最小需要是：上一个寄存器的输出信号达到稳定的时间 + 两个寄存器之间的组合电路运算结果达到稳定的时间 + 下一个寄存器的设置时间
                     $$
                     T_c \ge t_{pcq} + t_{pd} + t_{setup}
                     $$
                     进一步，如果时钟周期已经确定
                     $$
                     t_{pd} \le T_c-(t_{pcq} + t_{setup})
                     $$
                     这样的结构中，时序开销为：$(t_{pcq}+t_{setup})$
            
                     <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-18 173851.png" alt="Screenshot 2025-12-18 173851" style="zoom:50%;" />
            
                  2. 维持时间限制
            
                     上一个寄存器的信号必须维持稳定的时间是：从CLK输入，到组合逻辑电路的输出开始波动的时间
                     $$
                     t_{hold} < t_{ccq}+t_{cd}
                     $$
                     **注意：这里t~cd~是从寄存器输出开始发生变化开始计算，而不是输出稳定**
            
                     <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-18 175824.png" alt="Screenshot 2025-12-18 175824" style="zoom:50%;" />
            
                     * 单位转换：**延迟的单位一般是ps，这个单位直接取倒数得到的数字乘1000的单位就是GHz**
            

## 九 计数器 C10

本节中出现的计数器都是文字生成器，模数均为n^2^

1. 异步计数器（行波计数器）

   异步计数器中的寄存器不共用时钟刻，用的是D触发器

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-18 181843.png" alt="Screenshot 2025-12-18 181843" style="zoom: 67%;" />

   每一位寄存器都需要等待前一位寄存器处理完毕，因此它的延迟会诸位累加

   假设一个寄存器的传播延迟为 t 秒，则

   总延迟：t~p~ = t * (寄存器的数量)

   最大时钟频率：f~max~ = 1 / t~p~

   * 异步十进制计数器

     在10的二进制对应位数的寄存器输出连接一个检测逻辑并接到CLR上

     <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-18 235253.png" alt="Screenshot 2025-12-18 235253" style="zoom: 67%;" />

2. 同步寄存器

   所有寄存器共用时钟刻，用的是JK触发器

   下一位的变动条件是：前面所有位都为1。因此每一位的输入都会把前面所有输出AND起来

   （不用每次单独AND，可以把前一位的与门输出直接拉过来）

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-18 221756.png" alt="Screenshot 2025-12-18 221756" style="zoom: 67%;" />

   * 同步十进制计数器

     每次检测到9的时候（1001），在下一时刻把最高位反转。（个位自己会变成0）

     <img src="D:\大学\笔记\大二上\用到的图片\da20b34e-4028-4d23-9b39-ca04775e6bfc.png" alt="da20b34e-4028-4d23-9b39-ca04775e6bfc" style="zoom: 67%;" />

   * 四位同步二进制计数器

     <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 000617.png" alt="Screenshot 2025-12-19 000617" style="zoom:60%;" />

     LOAD的时候将在下个时钟刻载入D的数据

     ENT和ENP必须同时为正才能让计数器开始运作

     当RCO位1时表明计数器达到了它的最高位15

3. 升 / 降同步计数器（双向同步计数器）

   额外有一个升降序开关，如果启用则产生升序数列，反之产生降序数列

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 001336.png" alt="Screenshot 2025-12-19 001336" style="zoom:60%;" />

   生成降序数列的原理就是：把每个寄存器的反向输出当作触发下一位反转的信号。

4. 设计一个同步计数器（没有输入的有限状态机）

   第一步：画出状态转换图

   第二步：画出下一时刻状态表

   第三步：得出触发器输入表

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 201732.png" alt="Screenshot 2025-12-19 201732" style="zoom:60%;" />

   **注意这里JK寄存器是可以设置don't care的，这样可以获得一些额外化简。**

   第四步：卡诺图化简

   第五步：写出每一个触发器每个输入的表达式

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 202351.png" alt="Screenshot 2025-12-19 202351" style="zoom: 50%;" />

   **这个是为了获得电路图最重要的一步**

   第六步：画出电路图

   提示：

   * **JK触发器的输入永远符合这个逻辑：**

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 233321.png" alt="Screenshot 2025-12-19 233321" style="zoom: 67%;" />

     所以如果要把D触发器用的表达式用JK触发器实现，可以直接套用这个式子

5. 级联计数器

   异步型：所有输入全部接高电平，每一位的反向输出作为下一位的CLK输入

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 005452.png" alt="Screenshot 2025-12-19 005452" style="zoom: 67%;" />

   同步型：直接串联，前一个计数器的最高位输出接到后一个计数器的使能开关

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 010712.png" alt="Screenshot 2025-12-19 010712" style="zoom:60%;" />

   * 每一位计数器的最高位可以视作是分割之后的频率
   * 串联计数器的总模数为每个计数器单元模数之积

6. 计数器的应用

   1. 数字时钟

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 014154.png" alt="Screenshot 2025-12-19 014154" style="zoom: 67%;" />

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 014336.png" alt="Screenshot 2025-12-19 014336" style="zoom:67%;" />

   2. 串行 / 并行数据转换器

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 014519.png" alt="Screenshot 2025-12-19 014519" style="zoom:67%;" />
   
   3. 降频
   
      频率 / 计数器模数 = 目标频率
   
      想要获得任意模数的计数器，首先先把手头的计数器串联得到大于目标模数的计数器，再在load的数据中预设（实际模数 - 目标模数）的二进制数，把最高位的输出接到load。这样每次load就会从预设的数开始数，就可以得到目标模数的计数器了。

## 十 内存与逻辑数组 C11

1. 存储阵列

   三种类型：

   * 动态内存DRAM
   * 静态内存SRAM
   * 只读内存ROM

   概念：

   * 存储阵列是一个二进制数存储单元的二维阵列

   * 每个存储单元存一位二进制数

   * 对于一个有N个地址比特和M个数据比特的阵列

     1. 它有 $2^N$ 行和 M 列

     2. 它的深度 = 行数 = 字数

     3. 它的宽度 = 列数 = 字宽

     4. 阵列大小 = 深 * 宽 = $2^N \times M$

        <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 015738.png" alt="Screenshot 2025-12-19 015738" style="zoom:67%;" />

2. 存储单元的读取

   字线WL：控制读取行的线，类似使能开关

   数据线BL：实际输入输出数据的线

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 020304.png" alt="Screenshot 2025-12-19 020304" style="zoom:60%;" />

   * 每条WL对应一个独特的地址
   * 一个阵列中同时只能有一条WL处于高电平

3. 内存类型

   1. RAM（随机存取存储器）
      * 易失：断电了数据就会消失
      * 读写非常迅速
   2. ROM（只读内存）
      * 不易失：断电了也还有数据
      * 读取很快，但是很难或不能写入

4. DRAM

   * 利用电容来存储数据

   * 需要时不时重新写入数据

   * 读取后就会销毁数据

     <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 021712.png" alt="Screenshot 2025-12-19 021712" style="zoom: 50%;" />

5. SRAM

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 022026.png" alt="Screenshot 2025-12-19 022026" style="zoom:60%;" />

6. ROM

   由于是只读的，用点表示高电平的比特

   <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 022907.png" alt="Screenshot 2025-12-19 022907" style="zoom: 50%;" />

   可以发现每一列都可以用来单独表示一个逻辑表达式

   更进一步，其实所有存储阵列都可以拿来这么玩，只需要在每一列的对应位写入高电平就行

7. PLA和FPGA

   1. PLA（可编程逻辑阵列）

      <img src="D:\大学\笔记\大二上\用到的图片\Screenshot 2025-12-19 024036.png" alt="Screenshot 2025-12-19 024036" style="zoom: 50%;" />

      一眼丁真的逻辑

   2. FPGA（现场可编程门列阵）

      拿着玩去吧
